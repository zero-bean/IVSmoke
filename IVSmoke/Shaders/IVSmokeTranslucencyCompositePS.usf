// IVSmokeTranslucencyCompositePS.usf
// Composites smoke OVER particles for TranslucencyAfterDOF render pass
// Engine will composite our output with SceneColor using alpha as transmittance

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"

Texture2D SmokeVisualTex;
Texture2D SmokeLocalPosAlphaTex;
Texture2D ParticleSceneTex;
SamplerState LinearClamp_Sampler;
float2 ParticlesTexExtent;
float2 ViewportSize;
float2 ViewRectMin;
int AlphaType; // 0 = Use Alpha as it is, 1 = Alpha <= CutOffValue ? 0 : 1
float AlphaThreshold;

void MainPS(
	float4 SvPosition : SV_POSITION,
	out float4 OutColor : SV_Target0)
{
	// UV Calculation - Extent based (UV = SvPosition / TexExtent)
	float2 SmokeUV = (SvPosition.xy - ViewRectMin) / ViewportSize;
	float2 ParticlesUV = (SvPosition.xy - ViewRectMin) / ParticlesTexExtent;

	// Sample smoke textures using smoke UV
	float4 SmokeVisual = SmokeVisualTex.Sample(LinearClamp_Sampler, SmokeUV);
	float4 ParticleScene = ParticleSceneTex.Sample(LinearClamp_Sampler, ParticlesUV);

	float SmokeAlpha = 0;
	if (AlphaType == 0)
	{
		//0 = Use Alpha as it is,
		SmokeAlpha = SmokeVisual.a;
	}
	else
	{
		// 1 = Alpha <= CutOffValue ? 0 : 1
		SmokeAlpha = SmokeVisual.a <= AlphaThreshold ? 0 : 1;
	}
	
	// SeparateTranslucency alpha IS transmittance (not opacity!)
	// ParticleScene.a = 1.0 means no particles (full transmittance)
	// ParticleScene.a = 0.0 means fully opaque particles
	float ParticlesTransmittance = ParticleScene.a;
	float TotalTransmittance = ParticlesTransmittance * saturate(1 - SmokeAlpha);
	OutColor.rgb = SmokeVisual.rgb + ParticleScene.rgb * saturate(1 - SmokeAlpha);
	OutColor.a = TotalTransmittance;
}
