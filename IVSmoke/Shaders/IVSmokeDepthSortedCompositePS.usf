// IVSmokeDepthSortedCompositePS.usf
// Depth-Sorted Composite using CustomDepth
// Compares smoke depth with particle CustomDepth to determine front/back ordering

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "/Engine/Private/ScreenPass.ush"
#include "/Engine/Private/DeferredShadingCommon.ush"

//~==============================================================================
// Input Textures

// Smoke layer (from ray marching CS)
Texture2D SmokeVisualTex;
Texture2D SmokeLocalPosAlphaTex;
Texture2D SmokeWorldPosDepthTex;

// Particle layer (from Separate Translucency)
Texture2D SeparateTranslucencyTex;

// Samplers
SamplerState PointClamp_Sampler;
SamplerState LinearClamp_Sampler;

//~==============================================================================
// Viewport - Texture Extents for UV calculation

// Texture Extents (UV = SvPosition / TexExtent)
float2 ViewportSize;
float2 ViewRectMin;

float4 InvDeviceZToWorldZTransform;

int AlphaType; // 0 = Use Alpha as it is, 1 = Alpha <= CutOffValue ? 0 : 1
float AlphaThreshold;

//~==============================================================================
// Helper Functions

/**
 * Check if CustomDepth contains valid data at this pixel.
 * Invalid data is typically at far plane (0.0 in reversed-Z) or unwritten.
 */
bool HasValidCustomDepth(float CustomDeviceZ)
{
	// In reversed-Z: 0.0 = far plane (invalid), values > 0 = valid
	return CustomDeviceZ > 0.0001 && CustomDeviceZ < 0.9999;
}

//~==============================================================================
// Main Depth-Sorted Composite Pixel Shader

void MainPS(
	float4 SvPosition : SV_POSITION,
	out float4 OutColor : SV_Target0)
{
	//~======================================================================
	// UV Calculation - Extent based
	// UV = SvPosition / TexExtent (direct texel-to-UV mapping)

	float2 SmokeUV = (SvPosition.xy - ViewRectMin) / ViewportSize;

	// Get actual texture dimensions for accurate UV (CL 277 style)
	uint TranslucencyWidth, TranslucencyHeight;
	SeparateTranslucencyTex.GetDimensions(TranslucencyWidth, TranslucencyHeight);
	float2 TranslucencyUV = (SvPosition.xy - ViewRectMin) / float2(TranslucencyWidth, TranslucencyHeight);

	float4 SmokeVisual = SmokeVisualTex.Sample(LinearClamp_Sampler, SmokeUV);
	float SmokeLinearDepth = SmokeWorldPosDepthTex.Sample(LinearClamp_Sampler, SmokeUV).a;
	
	float SmokeAlpha = 0;
	if (AlphaType == 0)
	{
		//0 = Use Alpha as it is,
		SmokeAlpha = SmokeVisual.a;
	}
	else
	{
		// 1 = Alpha <= CutOffValue ? 0 : 1
		SmokeAlpha = SmokeVisual.a <= AlphaThreshold ? 0 : 1;
	}
	
	// Particle layer (Separate Translucency: premultiplied alpha in RGB, transmittance in A)
	float4 ParticleScene = SeparateTranslucencyTex.Sample(LinearClamp_Sampler, TranslucencyUV);
	float3 ParticleColorPremul = ParticleScene.rgb;
	float ParticleTransmittance = ParticleScene.a;
	float ParticleAlpha = 1.0 - ParticleTransmittance;

	//~======================================================================
	// Depth Comparison
	// SmokeRayDepth = linear distance from camera to first smoke hit (from ray marching)
	// We need to compare this with particle depth.
	//
	// For particles: use CustomDepth if available, convert to linear depth
	// CustomDepth is in device-Z (reversed-Z: 1=near, 0=far), convert using InvDeviceZToWorldZTransform

	// Sample CustomDepth using direct pixel coordinates (Load method - CL 277 style)
	int2 PixelCoord = int2(SvPosition.xy);
	float CustomDeviceZ = SceneTexturesStruct.CustomDepthTexture.Load(int3(PixelCoord, 0)).r;

	// Convert CustomDepth device-Z to linear world depth
	float ParticleLinearDepth = 100000.0; // Default: very far (no particles)
	if (HasValidCustomDepth(CustomDeviceZ))
	{
		// InvDeviceZToWorldZTransform converts device Z to linear depth
		ParticleLinearDepth = CustomDeviceZ * InvDeviceZToWorldZTransform.x
			+ InvDeviceZToWorldZTransform.y
			+ 1.0 / (CustomDeviceZ * InvDeviceZToWorldZTransform.z - InvDeviceZToWorldZTransform.w);
	}

	// Depth comparison: lower value = closer to camera
	// SmokeInFront = true if smoke is closer than particles
	bool bSmokeInFront = (SmokeLinearDepth > 0.0) && (SmokeLinearDepth < ParticleLinearDepth);

	//~======================================================================
	// Particle presence check (supports both opaque and additive particles)
	// Additive particles have Transmittance = 1.0, so ParticleAlpha = 0
	// Use luminance to detect additive particles that have color but no alpha
	float ParticleLuminance = dot(ParticleColorPremul, float3(0.299, 0.587, 0.114));
	bool bHasParticles = (ParticleAlpha > 0.001) || (ParticleLuminance > 0.001);

	//~======================================================================
	// Composite (pre-multiplied alpha blending)
	//
	// IMPORTANT: In TranslucencyAfterDOF mode, engine composites as:
	//   Final = SceneColor * OutputAlpha + OutputRGB
	//
	// So OutputAlpha = TRANSMITTANCE (0 = opaque, 1 = transparent)
	// And OutputRGB = pre-multiplied color to ADD on top of background
	//
	// We should NOT include SceneColor in OutputRGB - engine handles that!

	float3 FinalColor;
	float FinalTransmittance;

	// No particles case - smoke only
	if (!bHasParticles)
	{
		// Smoke only: RGB = AccumulatedColor (pre-multiplied), A = Transmittance
		FinalColor = SmokeVisual.rgb;
		FinalTransmittance = saturate(1 - SmokeAlpha);
	}
	// No smoke case - particles only
	else if (SmokeAlpha < 0.001)
	{
		// Particles only: RGB = ParticleColorPremul, A = ParticleTransmittance
		FinalColor = ParticleColorPremul;
		FinalTransmittance = ParticleTransmittance;
	}
	// Both smoke and particles - depth-sorted blending
	else
	{
		if (bSmokeInFront)
		{
			// Smoke in front of particles
			// Composite: Smoke OVER Particles (both pre-multiplied)
			// RGB = Smoke + Particles * SmokeTransmittance
			// A   = SmokeTransmittance * ParticleTransmittance (combined transmittance)
			FinalColor = SmokeVisual.rgb + ParticleColorPremul * saturate(1 - SmokeAlpha);
			FinalTransmittance = saturate(1 - SmokeAlpha) * ParticleTransmittance;
		}
		else
		{
			// Particles in front of smoke
			// Composite: Particles OVER Smoke (both pre-multiplied)
			// RGB = Particles + Smoke * ParticleTransmittance
			// A   = ParticleTransmittance * SmokeTransmittance (combined transmittance)
			FinalColor = ParticleColorPremul + SmokeVisual.rgb * ParticleTransmittance;
			FinalTransmittance = ParticleTransmittance * saturate(1 - SmokeAlpha);
		}
	}

	OutColor = float4(FinalColor, FinalTransmittance);
}
